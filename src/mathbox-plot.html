<script src="mathbox/build/mathbox-bundle.js"></script>
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<dom-module id="mathbox-plot">
  <template>
    <style>
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
      }
    </style>
    <div id='mathbox'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        func: {
          type: Object,
          observer: '_funcChanged',
          value: {
            eval: (x)=> {return 0;}
          }
        },
        width: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        height: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        animated: {
          type: Boolean,
        }
      },

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
      },

      attached: function() {
        this.initialized = true;

        var aspectRatio = this._getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
          size: {}
        };
        if (this.width != 0) {
          options.size.width = this.width;
        }
        if (this.height != 0) {
          options.size.height = this.height;
        }
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        var camera = this.mathbox.camera({
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();

        this.data = this.view.interval({
          channels: 2,
          fps: 60
        });

        this.curve = this.view.line({
          width: 5,
          color: '#3090FF',
          zIndex: 2
        });

        this._resize();
        this._setupGridLines();
        this._initializeAnimators();
        this._plotFunction(false);
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      _funcChanged: function() {
        if (this.initialized) {
          this._plotFunction(this.animated);
        }
      },

      _plotFunction: function(animated = false) {
        var cachedExpr = this.func.eval;
        var newExpr = (emit, x, i, t) => {
          emit(x, cachedExpr(x));
        };
        var newRange = this._getBounds(newExpr, [0, 10]);

        if (animated) {
          var currExpr = this.data.get('expr');
          this.intervalAnim.set('script', {
            '0.001': {props: {expr: currExpr}},
            '1': {props: {expr: newExpr}},
          });

          var currRange = this.view.get('range');
          this.cartesianAnim.set('script', {
            '0.001': {props: {range: currRange}},
            '1': {props: {range: newRange}},
          });
        }
        else {
          this.data.set('expr', newExpr);
          this.view.set('range', newRange);
        }
      },

      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var aspectRatio = this._getAspectRatio();
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
        this.data.set('width', this._getWidth());
      },

      _getAspectRatio: function() {
        return this._getWidth()/this._getHeight();
      },

      _getWidth: function() {
        return this.width || this.scrollWidth;
      },

      _getHeight: function() {
        return this.height || this.scrollHeight;
      },

      _initializeAnimators: function() {
        this.cartesianAnim = this.mathbox.play({
          target: 'cartesian',
          pace: 1,
        });
        this.intervalAnim = this.mathbox.play({
          target: 'interval',
          pace: 1,
        });
      },

      _getBounds: function(dataExpr, range, numSamples=200) {
        // The range has a weird format; it gets stored as a Vector2.
        var minX = range[0], maxX = range[1];
        var xStep = (maxX-minX)/numSamples;
        var minY = Number.MAX_VALUE, maxY = -minY;
        var emit = function (x, y) {
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        };
        for (var i = 0; i < numSamples; i++) {
          var x = minX + i*xStep;
          dataExpr(emit, x);
        }
        if (minY == Number.NEGATIVE_INFINITY) {
          minY = -10;
        }
        if (maxY == Number.POSITIVE_INFINITY) {
          maxY = 10;
        }
        if (minY == maxY) {
          minY = minY - 5;
          maxY = maxY + 5;
        }
        minY = Math.min(minY, 0);
        maxY = Math.max(maxY, 0);
        return [[minX, maxX],[minY, maxY]];
      }

    });
 </script>
</dom-module>
