<script src="../libs/mathbox/build/mathbox-bundle.js"></script>
<script src="warm-cool-map.js"></script>
<script src="../bower_components/shifty/dist/shifty.min.js"></script>
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<dom-module id="mathbox-plot">
  <template>
    <style is="custom-style">
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
        transition: filter .5s;
      }
      :host(.ungrabbed) #mathbox {
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
      }
      iron-icon {
        display:none;
        opacity:0;
        position:absolute;
        z-index:1;
        left: 50%;
        top: 50%;
        transform: translate(-50%,-50%);
        --iron-icon-fill-color: #d40000;
        --iron-icon-stroke-color: rgba(0,0,0,0.1);
        --iron-icon-width: 64px;
        --iron-icon-height: 64px;
        transition: opacity .5s;
      }
      :host(.error) iron-icon {
        opacity:1;
        display:block;
      }
      :host(.error) #mathbox{
        filter:blur(10px);
      }
    </style>
    <iron-icon icon='error'></iron-icon>
    <div id='mathbox' class='blur'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        functor: Object,
        width: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        height: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        animated: Boolean,
        xRange: {
          type: Array,
          notify: true,
        },
        yRange: {
          type: Array,
          value: [-1, 1],
          readonly: true
        },
        inputOk: Boolean,
        dimensionsOk: Boolean
      },

      observers: [
        '_functorChanged(functor, functor.boundVars)',
        '_shouldError(inputOk, dimensionsOk)'
      ],

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
        'down': 'onPanStart',
        'wheel': 'onWheel'
      },

      attached: function() {
        this.initialized = true;

        var aspectRatio = this._getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
          size:{},
        };
        if (this.width != 0) {
          options.size.width = this.width;
        }
        if (this.height != 0) {
          options.size.height = this.height;
        }
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        var camera = this.mathbox.camera({
          proxy: true,
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();
        this.view.bind('range', ()=>{
          return [this.xRange, this.yRange];
        });

        this.tweeners = {};
        this.tweenerTargets = {};
        this.currDimensions = 0;
        this._setupDataAndDisplay(this.currDimensions);
        this._resize();
        this._setupGridLines();
        this._functionChanged(false);

        this.classList.add('ungrabbed');
      },

      _getAspectRatio: function() {
        return this._getWidth()/this._getHeight();
      },

      _getWidth: function() {
        return this.width || this.scrollWidth;
      },

      _getHeight: function() {
        return this.height || this.scrollHeight;
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var aspectRatio = this._getAspectRatio();
        //Maybe bind this?
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
      },

      _functorChanged: function() {
        if (this.initialized) {
          let newDimensions = this.functor.unboundVars().length;
          let dimensionsOk = newDimensions < 3;
          if (this._shouldReinitialize(newDimensions) && dimensionsOk) {
            this._setupDataAndDisplay(newDimensions);
          } 
          if (dimensionsOk) {
            this.dimensionsOk = true;
            this.cancelDebouncer('dimensions-error');
            this.currDimensions = newDimensions;
            this._functionChanged(this.animated);
          } 
          else {
            this.debounce('dimensions-error', (_)=> {
              this.dimensionsOk = false;
            }, 500);
          }
        }
      },

      _shouldError: function () {
        if (this.inputOk && this.dimensionsOk) {
          this.classList.remove('error');
        }
        else {
          this.classList.add('error');
        }
      },

      _shouldReinitialize: function(newDimensions) {
        switch(this.currDimensions) {
        case 0:
        case 1:
          return (newDimensions != 0 && newDimensions != 1);
        default:
          return (newDimensions != this.currDimensions);
        }
      },

      _setupDataAndDisplay: function(numDimensions) {
        let dataId = 'data';
        let displayId = 'display';
        let animId = 'anim';
        this.mathbox.remove('#' + dataId);
        this.mathbox.remove('#' + displayId);
        this.mathbox.remove('#' + animId);
        this.mathbox.remove('#flat');

        switch(numDimensions) {
        case 0:
        case 1:
          this.data = this.view.interval({
            channels: 2,
            fps: 60,
            id: dataId,
          }, {
            width: ()=>{return this._getWidth();}
          }
          );
          this.display = this.view.line({
            width: 5,
            color: '#3090FF',
            zIndex: 2,
            id: displayId
          });
          this.dataAnim = this.mathbox.play({
            target: '#data',
            pace: 1,
            id: animId
          });
          this._animateRange('xRange', [-5, 5], duration, 'easeInOutSine');
          break;
        case 2:
          var dim = 100;
          var flat = this.view.area({
            channels: 3,
            id: 'flat',
            width: dim,
            height: dim,
            expr: (emit, x, y) => {
              emit(x, y, 0);
            }
          });
          this.data = this.view.area({
            channels: 4,
            id: dataId,
            width: dim,
            height: dim
          });
          this.display = this.view.surface({
            colors: '#' + dataId,
            points: '#flat',
            id: displayId
          });
          this.dataAnim = this.mathbox.play({
            target: '#data',
            pace: 1,
            id: animId
          });
          var duration = this.dataAnim.get('pace')*1000;
          this._animateRange('xRange', [-5, 5], duration, 'easeInOutSine');
          this._animateRange('yRange', [-5, 5], duration, 'easeInOutSine');
        default:
        }
      },

      _getUnboundRanges: function () {
        switch (this.currDimensions) {
        case 0:
          return [];
        case 1:
          return [this._getFinalRange('xRange')];
        case 2:
          return [this._getFinalRange('xRange'), this._getFinalRange('yRange')];
        default:
          return null;
        }
      },

      _functionChanged: function(animated = false) {
        if (!this.functor) {
          return;
        }

        switch (this.currDimensions) {
        case 0:
        case 1:
          var cachedEval = this.functor.eval.bind(this.functor);
          var newExpr = (emit, x) => {
            emit(x, cachedEval(x));
          };
          this._resetMinMax(animated);
          this._changeExpr(newExpr, animated);
          break;
        case 2:
          var colorMap = (val) => {
            if (typeof val != 'number') {
              return [0,0,0];
            }
            var t = (val-this.colorRange[0])/(this.colorRange[1]-this.colorRange[0]);
            var i = Math.round(t*warmCoolMap.length);
            i = Math.min(Math.max(0, i), warmCoolMap.length-1);
            return warmCoolMap[i];
          };
          var cachedEval = this.functor.eval.bind(this.functor);
          var newExpr = (emit, x, y) => {
            let val = cachedEval(x, y);
            emit (...colorMap(val), 255);
          };
          this._resetMinMax(animated);
          this._changeExpr(newExpr, animated);
          break;
        }
      },

      _animateRange: function (name, targetRange, duration=250, easing='easeInOutSine') {
        if (!(name in this.tweeners)) {
          this.tweeners[name] = new Tweenable();
        }
        let tweener = this.tweeners[name];
        if (tweener.isPlaying()) {
          tweener.stop();
        }
        let startRange = this.get(name);
        if (!startRange) {
          this.set(name, targetRange);
        } 
        else {
          tweener.tween({
            from:     {min:  startRange[0], max:  startRange[1]},
            to:       {min: targetRange[0], max: targetRange[1]},
            duration: duration,
            easing:   easing,
            step: (state) => {
              this.set(name, [state.min, state.max]);
            }
          });
          this.tweenerTargets[name] = targetRange;
        }
      },

      //Where is the range now, or where will it be after it stops moving?
      _getFinalRange: function (name) {
        let tweener = this.tweeners[name];
        if (tweener && tweener.isPlaying()) {
          return this.tweenerTargets[name];
        } else {
          return this.get(name);
        }
      },

      //Apply some heuristics to get a good-looking range
      _guessYRange: function(minMax) {
        let minY = 0, maxY = 0;
        switch (this.currDimensions) {
        case 0:
          minY = maxY = this.functor.eval();
          break;
        case 1:
        case 2:
          minY = minMax[0];
          maxY = minMax[1];
          break;
        default:
          return this.yRange;
        }

        // Apply some tricks to the resulting values to get a good range
        if (minY == Number.NEGATIVE_INFINITY) {
          minY = -10;
        }
        if (maxY == Number.POSITIVE_INFINITY) {
          maxY = 10;
        }
        if (minY == maxY) {
          minY = minY - 5;
          maxY = maxY + 5;
        }
        minY = Math.min(minY, 0);
        maxY = Math.max(maxY, 0);
        return [minY, maxY];
      },

      _sampleFuncForBounds: function(functor, unboundRanges, numSamples=200) {
        let f = functor.clone();
        
        let unboundVars = f.unboundVars();
        if (unboundVars == 0) {
          return [f.eval(), f.eval()];
        }
        for (var i = 0; i < unboundRanges.length; i++) {
          let range = unboundRanges[i];
          let unboundVar = unboundVars[i];
          f.pinVar(unboundVar, 0, range);
        }

        let iterateSteps = {};
        let numSamplePoints = Math.round(Math.pow(numSamples, 1/f.symbols.length));
        for (let key in f.boundVars) {
          let currRange = f.boundVars[key].range;
          let rangeWidth = currRange[1]-currRange[0];
          iterateSteps[key] = rangeWidth/numSamplePoints;
        }

        var minY = Number.MAX_VALUE, maxY = -minY;
        var checkValue = function (y) {
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        };

        let iterate = (dimension) => {
          let currVar = f.symbols[dimension];
          let currRange = f.boundVars[currVar].range;
          let currStep = iterateSteps[currVar];
          for (let i = currRange[0]; i < currRange[1]; i+=currStep) {
            f.bindVar(currVar, i);
            if (dimension == f.symbols.length-1) {
              checkValue(f.eval());
            } else {
              iterate(dimension+1);
            }
          }
        };
        iterate(0);
        return [minY, maxY];
      },

      _resetMinMax: function(animated) {
        switch(this.currDimensions) {
        case 0:
        case 1:
          var newRange = this._sampleFuncForBounds(this.functor, this._getUnboundRanges());
          newRange = this._guessYRange(newRange);
          if (animated) {
            this._animateRange('yRange', newRange, 250, 'easeOutSine');
          }
          else {
            this.yRange = newRange;
          }
          break;
        case 2:
          var minMax = this._sampleFuncForBounds(this.functor, this._getUnboundRanges(), 5000);
          minMax = this._guessYRange(minMax);
          //The color range should be symmetric, centered on 0.
          var largestDisplacement = Math.max(Math.abs(minMax[0]), Math.abs(minMax[1]));
          var newColorRange = [-largestDisplacement, largestDisplacement];
          if (animated) {
            this._animateRange('colorRange', newColorRange, 250, 'easeOutSine');
          }
          else {
            this.colorRange = newColorRange;
          }
          break;
        }
      },

      _changeExpr: function (newExpr, animated) {
        if (animated && this.data.get('expr')) {
          var currExpr = this.data.get('expr');
          this.dataAnim.set('script', {
            '0.001': {props: {expr: currExpr}},
            '1': {props: {expr: newExpr}},
          });
        }
        else {
          this.data.set('expr', newExpr);
        }
      },

      onPanStart: function (e) {
        this.classList.remove('ungrabbed');
        this.lastPan = {x:e.detail.x, y:e.detail.y};
        this.listen(this, 'track', 'onPan');
        this.listen(this, 'up', 'onPanStop');
        for (let value of ['grabbing', '-webkit-grabbing', '-moz-grabbing']) {
          document.body.style.cursor = value;
          if (document.body.style.cursor  === value)
            break;
        }
      },

      onPan: function (e) {
        switch(this.currDimensions) {
        case 0:
        case 1:
          this.translateRange(e.detail.x - this.lastPan.x);
          break;
        case 2:
          this.translateRange(e.detail.x-this.lastPan.x, e.detail.y-this.lastPan.y);
          break;
        }
        this.lastPan = {x:e.detail.x, y:e.detail.y};
      },

      onPanStop: function (e) {
        this.classList.add('ungrabbed');
        this.lastPanX = null;
        this.unlisten(this, 'track', 'onPan');
        this.unlisten(this, 'up', 'onPanStop');
        document.body.style.cursor = null;
        this._resetMinMax(this.animated);
      },

      onWheel: function (e) {
        let zoomScale = .01;
        let zoomAmount = zoomScale*e.deltaY;
        this.zoomRange(zoomAmount, e.offsetX, e.offsetY);
      },

      translateRange(dx, dy) {
        if (dx) {
          let scale = (this.xRange[0]-this.xRange[1])/this._getWidth();
          let change = dx * scale;
          this.xRange = [this.xRange[0]+change, this.xRange[1]+change];
        }
        if (dy) {
          let scale = (this.yRange[0]-this.yRange[1])/this._getHeight();
          let change = -dy * scale;
          this.yRange = [this.yRange[0]+change, this.yRange[1]+change];
        }
      },

      zoomRange(zoomAmount, centerX, centerY) {
        let tX = centerX/this._getWidth();
        let tY = centerY/this._getHeight();

        let targetXRange = this.scaleRangeAround(this.xRange, tX, 1+zoomAmount);
        this._animateRange('xRange', targetXRange, 250, 'easeOutSine');

        if (this.currDimensions == 2) {
          var targetYRange = this.scaleRangeAround(this.yRange, tY, 1+zoomAmount);
          this._animateRange('yRange', targetYRange, 250, 'easeOutSine');
        }
        this._resetMinMax(this.animated);
      },

      scaleRangeAround(range, t, scale) {
        let width = range[1] - range[0];
        let focusPoint = range[0] + width*t;
        let newWidth = width*scale;
        return [focusPoint-t*newWidth, focusPoint+(1-t)*newWidth];
      }

    });
 </script>
</dom-module>
