<script src="../libs/mathbox/build/mathbox-bundle.js"></script>
<link rel="import" href="graphs/graph-import.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<dom-module id="mathbox-plot">
  <template>
    <style is="custom-style">
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
        transition: filter .5s;
      }
      :host(.ungrabbed) #mathbox {
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
      }
      iron-icon {
        display:none;
        opacity:0;
        position:absolute;
        z-index:1;
        left: 50%;
        top: 50%;
        transform: translate(-50%,-50%);
        --iron-icon-fill-color: #d40000;
        --iron-icon-stroke-color: rgba(0,0,0,0.1);
        --iron-icon-width: 64px;
        --iron-icon-height: 64px;
        transition: opacity .5s;
      }
      :host(.error) iron-icon {
        opacity:1;
        display:block;
      }
      :host(.error) #mathbox{
        filter:blur(10px);
      }
    </style>
    <iron-icon icon='error'></iron-icon>
    <div id='mathbox' class='blur'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        functor: Object,
        width: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        height: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        animated: Boolean,
        syncedParameters: {
          type: Object,
          notify: true,
          value: function() {return {
            xRange: [-5, 5],
            yRange: [-5, 5],
          };}
        },
        inputOk: Boolean,
        dimensionsOk: Boolean
      },

      observers: [
        '_functorChanged(functor, functor.boundVars)',
        '_shouldError(inputOk, dimensionsOk)'
      ],

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
        'down': 'onPanStart',
        'wheel': 'onWheel'
      },

      attached: function() {
        this.initialized = true;

        var aspectRatio = this._getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
          size:{},
        };
        if (this.width != 0) {
          options.size.width = this.width;
        }
        if (this.height != 0) {
          options.size.height = this.height;
        }
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        var camera = this.mathbox.camera({
          proxy: true,
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();


        this.supportedGraphs = [LineGraph, ColorGraph];
        this.tweeners = {};
        this.tweenerTargets = {};
        this.currDimensions = 0;
        this._setupDataAndDisplay(LineGraph);
        this._resize();
        this._setupGridLines();
        this._functionChanged(false);

        this.classList.add('ungrabbed');
      },

      _getAspectRatio: function() {
        return this._getWidth()/this._getHeight();
      },

      _getWidth: function() {
        return this.width || this.scrollWidth;
      },

      _getHeight: function() {
        return this.height || this.scrollHeight;
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var aspectRatio = this._getAspectRatio();
        //Maybe bind this?
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
      },

      _functorChanged: function() {
        if (this.initialized) {
          let compatibleGraphs = this._getCompatibleGraphs(this.functor);
          if (compatibleGraphs.length != 0) {
            if (!this.graph) {
              this._setupDataAndDisplay(compatibleGraphs[0]);
            } 
            else if (compatibleGraphs[0] !== this.graph.constructor) {
              if (this.graph) {
                this.graph.teardown();
              }
              this._setupDataAndDisplay(compatibleGraphs[0]);
            }
            this.dimensionsOk = true;
            this.cancelDebouncer('dimensions-error');
            this._functionChanged(this.animated);
          } 
          else {
            this.debounce('dimensions-error', (_)=> {
              this.dimensionsOk = false;
            }, 500);
          }
        }
      },

      _shouldError: function () {
        if (this.inputOk && this.dimensionsOk) {
          this.classList.remove('error');
        }
        else {
          this.classList.add('error');
        }
      },

      _getCompatibleGraphs: function (functor) {
        let matchingGraphs = this.supportedGraphs.filter((graph) => {
          return graph.isSupported(this.functor);
        });
        return matchingGraphs;
      },

      _setupDataAndDisplay: function(graphConstructor) {
        if (!this.functor)
          return;
        this.graph = new graphConstructor(this.mathbox, this.syncedParameters, this.animated);
        this.graph.setup();
      },

      _functionChanged: function(animated = false) {
        if (!this.functor || !this.graph) {
          return;
        }
        this.graph.showFunction(this.functor);
      },

      onPanStart: function (e) {
        this.classList.remove('ungrabbed');
        this.lastPan = {x:e.detail.x, y:e.detail.y};
        this.listen(this, 'track', 'onPan');
        this.listen(this, 'up', 'onPanStop');
        for (let value of ['grabbing', '-webkit-grabbing', '-moz-grabbing']) {
          document.body.style.cursor = value;
          if (document.body.style.cursor  === value)
            break;
        }
        this.graph.onPanStart();
      },

      onPan: function (e) {
        let dx = e.detail.x - this.lastPan.x;
        let dy = e.detail.y - this.lastPan.y;
        this.graph.onPan(dx, dy);
        this.lastPan = {x:e.detail.x, y:e.detail.y};
      },

      onPanStop: function (e) {
        this.graph.onPanStop();
        this.classList.add('ungrabbed');
        this.lastPanX = null;
        this.unlisten(this, 'track', 'onPan');
        this.unlisten(this, 'up', 'onPanStop');
        document.body.style.cursor = null;
      },

      onWheel: function (e) {
        this.graph.onZoom(e.deltaY, e.offsetX, e.offsetY);
      },
    });
 </script>
</dom-module>
