<script src="../libs/mathbox/build/mathbox-bundle.js"></script>
<script src="warm-cool-map.js"></script>
<link rel="import" href="graphs/graph-import.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<dom-module id="mathbox-plot">
  <template>
    <style is="custom-style">
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
        transition: filter .5s;
      }
      :host(.ungrabbed) #mathbox {
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
      }
      iron-icon {
        display:none;
        opacity:0;
        position:absolute;
        z-index:1;
        left: 50%;
        top: 50%;
        transform: translate(-50%,-50%);
        --iron-icon-fill-color: #d40000;
        --iron-icon-stroke-color: rgba(0,0,0,0.1);
        --iron-icon-width: 64px;
        --iron-icon-height: 64px;
        transition: opacity .5s;
      }
      :host(.error) iron-icon {
        opacity:1;
        display:block;
      }
      :host(.error) #mathbox{
        filter:blur(10px);
      }
    </style>
    <iron-icon icon='error'></iron-icon>
    <div id='mathbox' class='blur'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        functor: Object,
        width: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        height: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        animated: Boolean,
        syncedParameters: {
          type: Object,
          notify: true,
          value: function() {return {
            xRange: [-5, 5],
            yRange: [-5, 5],
          };}
        },
        // xRange: {
        //   type: Array,
        //   notify: true,
        // },
        // yRange: {
        //   type: Array,
        //   value: [-1, 1],
        //   readonly: true
        // },
        inputOk: Boolean,
        dimensionsOk: Boolean
      },

      observers: [
        '_functorChanged(functor, functor.boundVars)',
        '_shouldError(inputOk, dimensionsOk)'
      ],

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
        'down': 'onPanStart',
        'wheel': 'onWheel'
      },

      attached: function() {
        this.initialized = true;

        var aspectRatio = this._getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
          size:{},
        };
        if (this.width != 0) {
          options.size.width = this.width;
        }
        if (this.height != 0) {
          options.size.height = this.height;
        }
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        var camera = this.mathbox.camera({
          proxy: true,
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();


        // this.supportedGraphs = [LineGraph, ColorGraph];
        this.supportedGraphs = [LineGraph];
        this.tweeners = {};
        this.tweenerTargets = {};
        this.currDimensions = 0;
        this._setupDataAndDisplay();
        this._resize();
        this._setupGridLines();
        this._functionChanged(false);

        this.classList.add('ungrabbed');
      },

      _getAspectRatio: function() {
        return this._getWidth()/this._getHeight();
      },

      _getWidth: function() {
        return this.width || this.scrollWidth;
      },

      _getHeight: function() {
        return this.height || this.scrollHeight;
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var aspectRatio = this._getAspectRatio();
        //Maybe bind this?
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
      },

      _functorChanged: function() {
        if (this.initialized) {
          let newDimensions = this.functor.unboundVars.length;
          let dimensionsOk = (this._getCompatibleGraphs().length != 0);
          if (this._shouldReinitialize(newDimensions) && dimensionsOk) {
            if (this.graph) {
              this.graph.teardown();
            }
            this._setupDataAndDisplay(newDimensions);
          } 
          if (dimensionsOk) {
            this.dimensionsOk = true;
            this.cancelDebouncer('dimensions-error');
            this.currDimensions = newDimensions;
            this._functionChanged(this.animated);
          } 
          else {
            this.debounce('dimensions-error', (_)=> {
              this.dimensionsOk = false;
            }, 500);
          }
        }
      },

      _shouldError: function () {
        if (this.inputOk && this.dimensionsOk) {
          this.classList.remove('error');
        }
        else {
          this.classList.add('error');
        }
      },

      _shouldReinitialize: function(newDimensions) {
        switch(this.currDimensions) {
        case 0:
        case 1:
          return (newDimensions != 0 && newDimensions != 1);
        default:
          return (newDimensions != this.currDimensions);
        }
      },

      _getCompatibleGraphs: function (functor) {
        let matchingGraphs = this.supportedGraphs.filter((graph) => {
          return graph.isSupported(this.functor);
        });
        return matchingGraphs;
      },

      _setupDataAndDisplay: function() {
        if (!this.functor)
          return;
        let matchingGraphs = this._getCompatibleGraphs(this.functor);
        this.graph = new matchingGraphs[0](this.mathbox, this.syncedParameters, this.animated);
        this.graph.setup();
      },

      _getUnboundRanges: function () {
        switch (this.currDimensions) {
        case 0:
          return [];
        case 1:
          return [this._getFinalRange('xRange')];
        case 2:
          return [this._getFinalRange('xRange'), this._getFinalRange('yRange')];
        default:
          return null;
        }
      },

      _functionChanged: function(animated = false) {
        if (!this.functor || !this.graph) {
          return;
        }
        this.graph.showFunction(this.functor);
      },

      _animateRange: function (name, targetRange, duration=250, easing='easeInOutSine') {
        if (!(name in this.tweeners)) {
          this.tweeners[name] = new Tweenable();
        }
        let tweener = this.tweeners[name];
        if (tweener.isPlaying()) {
          tweener.stop();
        }
        let startRange = this.get(name);
        if (!startRange) {
          this.set(name, targetRange);
        } 
        else {
          tweener.tween({
            from:     {min:  startRange[0], max:  startRange[1]},
            to:       {min: targetRange[0], max: targetRange[1]},
            duration: duration,
            easing:   easing,
            step: (state) => {
              this.set(name, [state.min, state.max]);
            }
          });
          this.tweenerTargets[name] = targetRange;
        }
      },

      //Where is the range now, or where will it be after it stops moving?
      _getFinalRange: function (name) {
        let tweener = this.tweeners[name];
        if (tweener && tweener.isPlaying()) {
          return this.tweenerTargets[name];
        } else {
          return this.get(name);
        }
      },

      //Apply some heuristics to get a good-looking range
      _resetMinMax: function(animated) {
        switch(this.currDimensions) {
        case 0:
        case 1:

          break;
        case 2:
          var minMax = this._sampleFuncForBounds(this.functor, this._getUnboundRanges(), 5000);
          minMax = this._guessYRange(minMax);
          //The color range should be symmetric, centered on 0.
          var largestDisplacement = Math.max(Math.abs(minMax[0]), Math.abs(minMax[1]));
          var newColorRange = [-largestDisplacement, largestDisplacement];
          if (animated) {
            this._animateRange('colorRange', newColorRange, 250, 'easeOutSine');
          }
          else {
            this.colorRange = newColorRange;
          }
          break;
        }
      },

      _changeExpr: function (newExpr, animated) {
        if (animated && this.data.get('expr')) {
          var currExpr = this.data.get('expr');
          this.dataAnim.set('script', {
            '0.001': {props: {expr: currExpr}},
            '1': {props: {expr: newExpr}},
          });
        }
        else {
          this.data.set('expr', newExpr);
        }
      },

      onPanStart: function (e) {
        this.classList.remove('ungrabbed');
        this.lastPan = {x:e.detail.x, y:e.detail.y};
        this.listen(this, 'track', 'onPan');
        this.listen(this, 'up', 'onPanStop');
        for (let value of ['grabbing', '-webkit-grabbing', '-moz-grabbing']) {
          document.body.style.cursor = value;
          if (document.body.style.cursor  === value)
            break;
        }
      },

      onPan: function (e) {
        switch(this.currDimensions) {
        case 0:
        case 1:
          this.translateRange(e.detail.x - this.lastPan.x);
          break;
        case 2:
          this.translateRange(e.detail.x-this.lastPan.x, e.detail.y-this.lastPan.y);
          break;
        }
        this.lastPan = {x:e.detail.x, y:e.detail.y};
      },

      onPanStop: function (e) {
        this.classList.add('ungrabbed');
        this.lastPanX = null;
        this.unlisten(this, 'track', 'onPan');
        this.unlisten(this, 'up', 'onPanStop');
        document.body.style.cursor = null;
        this._resetMinMax(this.animated);
      },

      onWheel: function (e) {
        let zoomScale = .01;
        let zoomAmount = zoomScale*e.deltaY;
        this.zoomRange(zoomAmount, e.offsetX, e.offsetY);
      },

      translateRange(dx, dy) {
        if (dx) {
          let scale = (this.xRange[0]-this.xRange[1])/this._getWidth();
          let change = dx * scale;
          this.xRange = [this.xRange[0]+change, this.xRange[1]+change];
        }
        if (dy) {
          let scale = (this.yRange[0]-this.yRange[1])/this._getHeight();
          let change = -dy * scale;
          this.yRange = [this.yRange[0]+change, this.yRange[1]+change];
        }
      },

      zoomRange(zoomAmount, centerX, centerY) {
        let tX = centerX/this._getWidth();
        let tY = centerY/this._getHeight();

        let targetXRange = this.scaleRangeAround(this.xRange, tX, 1+zoomAmount);
        this._animateRange('xRange', targetXRange, 250, 'easeOutSine');

        if (this.currDimensions == 2) {
          var targetYRange = this.scaleRangeAround(this.yRange, tY, 1+zoomAmount);
          this._animateRange('yRange', targetYRange, 250, 'easeOutSine');
        }
        this._resetMinMax(this.animated);
      },

      scaleRangeAround(range, t, scale) {
        let width = range[1] - range[0];
        let focusPoint = range[0] + width*t;
        let newWidth = width*scale;
        return [focusPoint-t*newWidth, focusPoint+(1-t)*newWidth];
      }

    });
 </script>
</dom-module>
