<script src="mathbox/build/mathbox-bundle.js"></script>
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<dom-module id="mathbox-plot">
  <template>
    <style>
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
      }
    </style>
    <div id='mathbox'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        func: {
          type: Object,
          observer: '_funcChanged'
        }
      },

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
      },

      attached: function() {
        var plotEl = this.$.mathbox;
        this.initialized = true;
        var width = this.scrollWidth, height = this.scrollHeight;
        var aspectRatio = width/height;

        this.mathbox = mathBox({
          plugins: ['core', 'cursor', 'mathbox'],
          element: plotEl,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          }
        });
        var three = this.mathbox.three;
        three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);
        var camera = this.mathbox.camera({
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian({
          range: [[0,10], [0, 1]],
        });

        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });

        this.data =
        this.view.interval({
          expr: function (emit, x, i, t) {
            emit(x, 0);
          },
          width: plotEl.offsetWidth,
          channels: 2,
          fps: 60
        });
        var curve = 
        this.view.line({
          width: 5,
          color: '#3090FF',
          zIndex: 2
        });

        this.cartesianAnim = this.mathbox.play({
          target: 'cartesian',
          pace: 1,
        });
        this.intervalAnim = this.mathbox.play({
          target: 'interval',
          pace: 1,
        });
        this._resize();
      },
      _funcChanged: function() {
        if (typeof this.func.eval != 'undefined' && this.data) {
          var currFunc = this.func.eval;
          var currExpr = this.data.get('expr');
          var newExpr = function (emit, x, i, t) {
            emit(x, currFunc(x));
          };
          this.intervalAnim.set('script', {
            '0.001': {props: {expr: currExpr}},
            '1': {props: {expr: newExpr}},
          });

          var currRange = this.view.get('range');
          var newRange = this._getBounds(newExpr, this.view);
          this.cartesianAnim.set('script', {
            '0.001': {props: {range: currRange}},
            '1': {props: {range: newRange}},
          });
        }
      },
      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var width = this.scrollWidth, height = this.scrollHeight;
        var aspectRatio = width/height;
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
      },

      _getBounds: function(dataExpr, view, numSamples=200) {
        var xRange = view.get('range')[0];
        // The range has a weird format; it gets stored as a Vector2.
        var minX = xRange.x, maxX = xRange.y;
        var xStep = (maxX-minX)/numSamples;
        var minY = 0, maxY = 0;
        var emit = function (x, y) {
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        };
        for (var i = 0; i < numSamples; i++) {
          var x = minX + i*xStep;
          dataExpr(emit, x);
        }
        if (minY == Number.NEGATIVE_INFINITY) {
          minY = -10;
        }
        if (maxY == Number.POSITIVE_INFINITY) {
          maxY = 10;
        }
        if (minY == maxY) {
          minY = minY - 5;
          maxY = maxY + 5;
        }
        return [[minX, maxX],[minY, maxY]];
      }

    });
 </script>
</dom-module>
