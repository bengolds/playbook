<script src="../libs/mathbox/build/mathbox-bundle.js"></script>
<link rel="import" href="graphs/graph-import.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<dom-module id="mathbox-plot">
  <template>
    <style is="custom-style">
      :host {
        position:relative;
        overflow:hidden;
        display: block;
        flex-grow: 1;
      }
      #mathbox {
        height: 100%;
        width: 100%;
        transition: filter .5s;
      }
      :host(.ungrabbed) #mathbox {
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
      }
      #errorIcon {
        display:none;
        opacity:0;
        position:absolute;
        z-index:1;
        left: 50%;
        top: 50%;
        transform: translate(-50%,-50%);
        --iron-icon-fill-color: #d40000;
        --iron-icon-stroke-color: rgba(0,0,0,0.1);
        --iron-icon-width: 64px;
        --iron-icon-height: 64px;
        transition: opacity .5s;
      }
      :host(.error) #errorIcon {
        opacity:1;
        display:block;
      }
      :host(.error) #mathbox{
        filter:blur(10px);
      }
    </style>
    <iron-icon id='errorIcon' icon='error'></iron-icon>
    <div id='mathbox' class='blur'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        animated: Boolean,
        compiledFunction: {
          type: Object,
          observer: 'compiledFunctionChanged'
        },
        syncedParameters: {
          type: Object,
          notify: true,
          value: function() {return {
            xRange: [-5, 5],
            yRange: [-5, 5],
          };}
        },
        noGraphFound: {
          type: Boolean,
          notify: true,
          readOnly: true,
          value: true
        },
        showError: {
          type: Boolean,
          notify: false,
          observer: 'showErrorChanged'
        }
      },

      observers: [
        'compiledFunctionChanged(compiledFunction.globalScope.pinnedVariables.splices)'
      ],

      listeners: {
        'resize': 'resize',
        'down': 'onPanStart',
        'wheel': 'onWheel'
      },

      attached: function() {
        this.initialized = true;
        this.supportedGraphs = [LineGraph, ColorGraph];

        var aspectRatio = this.getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
        };
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        this.camera = this.mathbox.camera({
          proxy: true,
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();

        this.resize();
        this._setupGridLines();

        this.classList.add('ungrabbed');
      },

      detached: function() {
        if (this.mathbox.three) {
          this.mathbox.three.renderer.forceContextLoss() ;
          this.mathbox.three.destroy();
        }
      },

      showErrorChanged: function () {
        if (this.showError) {
          this.classList.add('error');
        } 
        else {
          this.classList.remove('error');
        }
      },

      getAspectRatio: function() {
        return this.offsetWidth/this.offsetHeight;
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      resize: function() {
        if (!this.initialized)
          return;
        this.mathbox.three.canvas.style.width = this.offsetWidth+'px';
        this.mathbox.three.canvas.style.height = this.offsetHeight+'px';

        let aspectRatio = this.getAspectRatio();
        //Maybe bind this?
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
      },

      compiledFunctionChanged: function() {
        if (!this.initialized)
          return;

        let newSignature = this.compiledFunction.getSignature();
        if (!this.graph || !this.graph.constructor.isSupported(newSignature)) {
          let graphConstructor = this._getCompatibleGraph();
          if (graphConstructor) {
            if (this.graph) {
              this.graph.teardown();
            }
            this.graph = new graphConstructor(this.mathbox, this.syncedParameters, this.animated);
            this.graph.setup();
            this._setNoGraphFound(false);
            this.fire('graph-ok');
            this.graph.showFunction(this.compiledFunction);
          }
          else {
            this._setNoGraphFound(true);
            this.fire('graph-error');
          }
        }
        else {
          this.graph.showFunction(this.compiledFunction);
        }

      },

      _getCompatibleGraph: function() {
        let matchingGraphs = this.supportedGraphs.filter((graph) => {
          return graph.isSupported(this.compiledFunction.getSignature());
        });
        if (matchingGraphs.length != 0) {
          return matchingGraphs[0];
        }
        else {
          return null;
        }
      },

      onPanStart: function (e) {
        this.classList.remove('ungrabbed');
        this.lastPan = {x:e.detail.x, y:e.detail.y};
        this.listen(this, 'track', 'onPan');
        this.listen(this, 'up', 'onPanStop');
        for (let value of ['grabbing', '-webkit-grabbing', '-moz-grabbing']) {
          document.body.style.cursor = value;
          if (document.body.style.cursor  === value)
            break;
        }
        this.graph.onPanStart();
      },

      onPan: function (e) {
        let dx = e.detail.x - this.lastPan.x;
        let dy = e.detail.y - this.lastPan.y;
        this.graph.onPan(dx, dy);
        this.lastPan = {x:e.detail.x, y:e.detail.y};
      },

      onPanStop: function (e) {
        this.graph.onPanStop();
        this.classList.add('ungrabbed');
        this.lastPanX = null;
        this.unlisten(this, 'track', 'onPan');
        this.unlisten(this, 'up', 'onPanStop');
        document.body.style.cursor = null;
      },

      onWheel: function (e) {
        this.graph.onZoom(e.deltaY, e.offsetX, e.offsetY);
      },
    });
 </script>
</dom-module>
