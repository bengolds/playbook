<script src="../libs/mathbox/build/mathbox-bundle.js"></script>
<script src="../bower_components/shifty/dist/shifty.min.js"></script>
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<dom-module id="mathbox-plot">
  <template>
    <style is="custom-style">
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
        transition: filter .5s;
      }
      :host(.ungrabbed) #mathbox {
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
      }
      iron-icon {
        display:none;
        opacity:0;
        position:absolute;
        z-index:1;
        left: 50%;
        top: 50%;
        transform: translate(-50%,-50%);
        --iron-icon-fill-color: #d40000;
        --iron-icon-stroke-color: rgba(0,0,0,0.1);
        --iron-icon-width: 64px;
        --iron-icon-height: 64px;
        transition: opacity .5s;
      }
      :host(.error) iron-icon {
        opacity:1;
        display:block;
      }
      :host(.error) #mathbox{
        filter:blur(10px);
      }
    </style>
    <iron-icon icon='error'></iron-icon>
    <div id='mathbox' class='blur'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        functor: {
          type: Object,
        },
        width: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        height: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        animated: {
          type: Boolean,
        },
        xRange: {
          type: Array,
          notify: true,
        },
        yRange: {
          type: Array,
          value: [-1, 1],
          readonly: true
        },
      },

      observers: [
        '_functorChanged(functor, functor.boundVars)'
      ],

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
        'down': 'onPanStart',
        'wheel': 'onWheel'
      },

      attached: function() {
        this.initialized = true;

        var aspectRatio = this._getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
          size:{},
        };
        if (this.width != 0) {
          options.size.width = this.width;
        }
        if (this.height != 0) {
          options.size.height = this.height;
        }
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        var camera = this.mathbox.camera({
          proxy: true,
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();
        this.view.bind('range', this.getRange.bind(this));

        this.data = this.view.interval({
          channels: 2,
          fps: 60
        });

        this.curve = this.view.line({
          width: 5,
          color: '#3090FF',
          zIndex: 2
        });

        this._resize();
        this._setupGridLines();
        this._initializeAnimators();
        this._plotFunction(false);

        this.classList.add('ungrabbed');
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      _functorChanged: function() {
        if (this.initialized) {
          this._plotFunction(this.animated);
        }
      },

      _plotFunction: function(animated = false) {
        if (!this.functor) {
          return;
        }
        var cachedExpr = this.functor.eval.bind(this.functor);
        var newExpr = (emit, x, i, t) => {
          emit(x, cachedExpr(x));
        };

        var newRange = this._computeYRange(this.xRange);

        if (animated) {
          var currExpr = this.data.get('expr');
          this.intervalAnim.set('script', {
            '0.001': {props: {expr: currExpr}},
            '1': {props: {expr: newExpr}},
          });
          var duration = this.intervalAnim.get('pace')*1000;
          this._animateRange('yRange', newRange, duration, 'easeInOutSine');
        }
        else {
          this.data.set('expr', newExpr);
          this.yRange = newRange;
        }
      },

      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var aspectRatio = this._getAspectRatio();
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
        this.data.set('width', this._getWidth());
      },

      _getAspectRatio: function() {
        return this._getWidth()/this._getHeight();
      },

      _getWidth: function() {
        return this.width || this.scrollWidth;
      },

      _getHeight: function() {
        return this.height || this.scrollHeight;
      },

      _initializeAnimators: function() {
        this.intervalAnim = this.mathbox.play({
          target: 'interval',
          pace: 1,
        });
        this.tweeners = {};
      },

      _computeYRange: function(range, numSamples=200) {
        let minY = 0, maxY = 0;
        switch (this.functor.unboundVars().length) {
        case 0:
          minY = maxY = this.functor.eval();
          break;
        case 1:
          var sampledRange = this._sampleFuncForBounds(this.functor, range, numSamples);
          minY = sampledRange[0];
          maxY = sampledRange[1];
          break;
        default:
          return this.yRange;
        }

        // Apply some tricks to the resulting values to get a good range
        if (minY == Number.NEGATIVE_INFINITY) {
          minY = -10;
        }
        if (maxY == Number.POSITIVE_INFINITY) {
          maxY = 10;
        }
        if (minY == maxY) {
          minY = minY - 5;
          maxY = maxY + 5;
        }
        minY = Math.min(minY, 0);
        maxY = Math.max(maxY, 0);
        return [minY, maxY];
      },

      _sampleFuncForBounds: function(functor, range, numSamples) {
        let f = functor.clone();
        
        if (f.unboundVars().length == 1) {
          f.pinVar(f.unboundVars()[0], 0, range);
        }

        let iterateSteps = {};
        let numSamplePoints = Math.round(Math.pow(numSamples, 1/f.symbols.length));
        for (let key in f.boundVars) {
          let currRange = f.boundVars[key].range;
          let rangeWidth = currRange[1]-currRange[0];
          iterateSteps[key] = rangeWidth/numSamplePoints;
        }

        var minY = Number.MAX_VALUE, maxY = -minY;
        var checkValue = function (y) {
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        };

        let iterate = (dimension) => {
          let currVar = f.symbols[dimension];
          let currRange = f.boundVars[currVar].range;
          let currStep = iterateSteps[currVar];
          for (let i = currRange[0]; i < currRange[1]; i+=currStep) {
            f.bindVar(currVar, i);
            if (dimension == f.symbols.length-1) {
              checkValue(f.eval());
            } else {
              iterate(dimension+1);
            }
          }
        };
        iterate(0);
        return [minY, maxY];
      },

      onPanStart: function (e) {
        this.classList.remove('ungrabbed');
        this.lastPanX = e.detail.x;
        this.listen(this, 'track', 'onPan');
        this.listen(this, 'up', 'onPanStop');
        for (let value of ['grabbing', '-webkit-grabbing', '-moz-grabbing']) {
          document.body.style.cursor = value;
          if (document.body.style.cursor  === value)
            break;
        }
      },

      onPan: function (e) {
        this.translateRange(e.detail.x - this.lastPanX);
        this.lastPanX = e.detail.x;
      },

      onPanStop: function (e) {
        this.classList.add('ungrabbed');
        this.lastPanX = null;
        this.unlisten(this, 'track', 'onPan');
        this.unlisten(this, 'up', 'onPanStop');
        document.body.style.cursor = null;
        this._animateRange('yRange', this._computeYRange(this.xRange), 250, 'easeOutSine');
      },

      _animateRange: function (name, targetRange, duration=250, easing='easeInOutSine') {
        if (!(name in this.tweeners)) {
          this.tweeners[name] = new Tweenable();
        }
        let tweener = this.tweeners[name];
        if (tweener.isPlaying) {
          tweener.stop();
        }
        let startRange = this.get(name);
        tweener.tween({
          from:     {min:  startRange[0], max:  startRange[1]},
          to:       {min: targetRange[0], max: targetRange[1]},
          duration: duration,
          easing:   easing,
          step: (state) => {
            this.set(name, [state.min, state.max]);
          }
        });
      },

      onWheel: function (e) {
        this.zoomRange(e.deltaY, e.offsetX, e.offsetY);
      },

      translateRange(dx) {
        if (dx) {
          let scale = (this.xRange[0]-this.xRange[1])/this._getWidth();
          let change = dx * scale;
          this.xRange = [this.xRange[0]+change, this.xRange[1]+change];
        }
      },

      zoomRange(zoomAmount, centerX, centerY) {
        let t = centerX/this._getWidth();
        let focusPoint = this.xRange[0] + (this.xRange[1]-this.xRange[0])*t;

        let scale = .01;
        let width = this.xRange[1] - this.xRange[0];
        let newWidth = width*(1+scale*zoomAmount);

        let targetXRange = [focusPoint-t*newWidth, focusPoint+(1-t)*newWidth];
        this._animateRange('xRange', targetXRange, 250, 'easeOutSine');
        let targetYRange = this._computeYRange(targetXRange);
        this._animateRange('yRange', targetYRange, 250, 'easeOutSine');
      },

      getRange(time, delta) {
        return [this.xRange, this.yRange];
      }

    });
 </script>
</dom-module>
