<script src="mathbox/build/mathbox-bundle.js"></script>
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<dom-module id="mathbox-plot">
  <template>
    <style>
      :host {
        height:100%;
        position:relative;
        overflow:hidden;
      }
      #mathbox {
        position:absolute;
        top:0px;
        bottom:0px;
        right:0px;
        left:0px;
      }
    </style>
    <div id='mathbox'></div>
    
  </template>

  <script>
    Polymer({
      is: 'mathbox-plot',

      properties: {
        functor: {
          type: Object,
          observer: '_functorChanged'
        },
        width: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        height: {
          type: Number,
          observer: '_resize',
          value: 0
        },
        animated: {
          type: Boolean,
        }
      },

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resize',
      },

      attached: function() {
        this.initialized = true;

        var aspectRatio = this._getAspectRatio();
        var options = {
          plugins: ['core', 'cursor', 'mathbox'],
          element: this.$.mathbox,
          camera: {
            type: 'orthographic',
            left: -aspectRatio,
            right: aspectRatio
          },
          size: {}
        };
        if (this.width != 0) {
          options.size.width = this.width;
        }
        if (this.height != 0) {
          options.size.height = this.height;
        }
        this.mathbox = mathBox(options);
        this.mathbox.three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

        var camera = this.mathbox.camera({
          position: [0,0,1]
        });

        this.view = this.mathbox.cartesian();

        this.data = this.view.interval({
          channels: 2,
          fps: 60
        });

        this.curve = this.view.line({
          width: 5,
          color: '#3090FF',
          zIndex: 2
        });

        this._resize();
        this._setupGridLines();
        this._initializeAnimators();
        this._plotFunction(false);
      },

      _setupGridLines: function() {
        this.view.axis({
          axis: 1,
          width: 4
        })
        .axis({
          axis: 2,
          width: 4
        })
        .grid({
          width: 1,
          divideX: 20,
          divideY: 10,
        });
      },

      _functorChanged: function() {
        if (this.initialized) {
          this._plotFunction(this.animated);
        }
      },

      _plotFunction: function(animated = false) {
        if (!this.functor) {
          return;
        }
        var cachedExpr = this.functor.eval.bind(this.functor);
        var newExpr = (emit, x, i, t) => {
          emit(x, cachedExpr(x));
        };
        var newRange = this._getBounds(newExpr, [0, 10]);

        if (animated) {
          var currExpr = this.data.get('expr');
          this.intervalAnim.set('script', {
            '0.001': {props: {expr: currExpr}},
            '1': {props: {expr: newExpr}},
          });

          var currRange = this.view.get('range');
          this.cartesianAnim.set('script', {
            '0.001': {props: {range: currRange}},
            '1': {props: {range: newRange}},
          });
        }
        else {
          this.data.set('expr', newExpr);
          this.view.set('range', newRange);
        }
      },

      _resize: function() {
        if (!this.initialized)
          return;
        var plotEl = this.$.mathbox;
        var aspectRatio = this._getAspectRatio();
        this.view.set('scale', [aspectRatio, 1]);
        this.mathbox.three.camera.left = -aspectRatio;
        this.mathbox.three.camera.right = aspectRatio;
        this.data.set('width', this._getWidth());
      },

      _getAspectRatio: function() {
        return this._getWidth()/this._getHeight();
      },

      _getWidth: function() {
        return this.width || this.scrollWidth;
      },

      _getHeight: function() {
        return this.height || this.scrollHeight;
      },

      _initializeAnimators: function() {
        this.cartesianAnim = this.mathbox.play({
          target: 'cartesian',
          pace: 1,
        });
        this.intervalAnim = this.mathbox.play({
          target: 'interval',
          pace: 1,
        });
      },

      _getBounds: function(dataExpr, range, numSamples=200) {
        let minY = 0, maxY = 0;
        switch (this.functor.unboundVars.length) {
        case 0:
          minY = maxY = this.functor.eval();
          break;
        case 1:
          var sampledRange = this._sampleFuncForBounds(this.functor, range, numSamples);
          minY = sampledRange[0];
          maxY = sampledRange[1];
          break;
        default:
          throw 'Too many unbound variables to calculate range';
        }

        // Apply some tricks to the resulting values to get a good range
        if (minY == Number.NEGATIVE_INFINITY) {
          minY = -10;
        }
        if (maxY == Number.POSITIVE_INFINITY) {
          maxY = 10;
        }
        if (minY == maxY) {
          minY = minY - 5;
          maxY = maxY + 5;
        }
        minY = Math.min(minY, 0);
        maxY = Math.max(maxY, 0);
        return [range,[minY, maxY]];
      },

      _sampleFuncForBounds: function(functor, range, numSamples) {
        let oldBoundVars = Object.assign({}, functor.boundVars);
        let oldUnboundVars = functor.unboundVars.slice(0);
        
        let iterateVars = functor.symbols.slice(0);
        let iterateRanges = Object.assign({}, functor.boundRanges);
        if (functor.unboundVars.length == 1) {
          iterateRanges[functor.unboundVars[0]] = range;
        }
        let iterateSteps = {};
        let numSamplePoints = Math.round(Math.pow(numSamples, 1/iterateVars.length));

        for (let key in iterateRanges) {
          let currRange = iterateRanges[key];
          let rangeWidth = currRange[1]-currRange[0];
          iterateSteps[key] = rangeWidth/numSamplePoints;
        }

        var minY = Number.MAX_VALUE, maxY = -minY;
        var checkValue = function (y) {
          if (!isNaN(y)) {
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        };

        let iterate = (dimension) => {
          let currVar = iterateVars[dimension];
          let currRange = iterateRanges[currVar];
          let currStep = iterateSteps[currVar];
          for (let i = currRange[0]; i < currRange[1]; i+=currStep) {
            functor.bindVar(currVar, i);
            if (dimension == iterateVars.length-1) {
              checkValue(functor.eval());
            } else {
              iterate(dimension+1);
            }
          }
        };
        iterate(0);
        functor.boundVars = oldBoundVars;
        functor.unboundVars = oldUnboundVars;
        return [minY, maxY];
      },

    });
 </script>
</dom-module>
