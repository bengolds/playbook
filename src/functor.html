<script>
class Functor {
  constructor(compiled, symbols) {
    this.compiled = compiled;
    this.symbols = symbols.slice();
    this.boundVars = {};
  }

  eval(...args) {
    var scope = {};
    var unboundVars = this.unboundVars();
    if (unboundVars.length <= args.length) {
      for (var i = 0; i < unboundVars.length; i++) {
        scope[unboundVars[i]] = args[i];
      }
    } 

    Object.assign(scope, this.scope());
    return this.compiled.eval(scope);
  }

  hardAssert(fact, message) {
    if (!fact)
      throw Error(message);
  }

  checkIsInFunction(symbol) {
    this.hardAssert(this.symbols.includes(symbol),
      symbol + ' was not found in function');
  }

  unboundVars() {
    return this.symbols.filter((x) => {
      return !(x in this.boundVars);
    });
  }

  scope() {
    let scope = {};
    for (let key in this.boundVars) {
      scope[key] = this.boundVars[key].value;
    }
    return scope;
  }

  pinVar(symbol, value, range) {
    this.checkIsInFunction(symbol);

    let wasAlreadyPinned = symbol in this.boundVars;

    this.boundVars[symbol] = {
      value: value,
      range: range
    };

    return !wasAlreadyPinned;
  }

  unpinVar(symbol) {
    this.checkIsInFunction(symbol);

    let wasAlreadyPinned = symbol in this.boundVars;

    delete this.boundVars[symbol];

    return wasAlreadyPinned;
  }

  bindVar(symbol, value) {
    this.checkIsInFunction(symbol);
    this.hardAssert(symbol in this.boundVars, symbol + ' is not pinned');

    this.boundVars[symbol].value = value;
  }

  clone() {
    var clone = new Functor(this.compiled, this.symbols);
    for (let key in this.boundVars) {
      clone.boundVars[key] = Object.assign({}, this.boundVars[key]);
    }
    return clone;
  }
}
</script>
