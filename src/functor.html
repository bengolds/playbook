<script>
class Functor {
  constructor(  compiled, symbols) {
    this.compiled = compiled;
    this.symbols = symbols.slice().sort();
    this.boundVars = {};
  }

  eval(...args) {
    var scope = {};
    var unboundVars = this.unboundVars;
    if (unboundVars.length <= args.length) {
      for (var i = 0; i < unboundVars.length; i++) {
        scope[unboundVars[i]] = args[i];
      }
    } 

    Object.assign(scope, this.scope());
    return this.compiled.eval(scope);
  }

  hardAssert(fact, message) {
    if (!fact)
      throw Error(message);
  }

  checkIsInFunction(symbol) {
    this.hardAssert(this.symbols.includes(symbol),
      symbol + ' was not found in function');
  }

  get unboundVars() {
    return this.symbols.filter((x) => {
      return !(x in this.boundVars);
    });
  }

  scope() {
    let scope = {};
    for (let key in this.boundVars) {
      scope[key] = this.boundVars[key].value;
    }
    return scope;
  }

  pinVar(symbol, value, range) {
    this.checkIsInFunction(symbol);

    let wasAlreadyPinned = symbol in this.boundVars;

    this.boundVars[symbol] = {
      value: value,
      range: range
    };

    return !wasAlreadyPinned;
  }

  unpinVar(symbol) {
    this.checkIsInFunction(symbol);

    let wasAlreadyPinned = symbol in this.boundVars;

    delete this.boundVars[symbol];

    return wasAlreadyPinned;
  }

  bindVar(symbol, value) {
    this.checkIsInFunction(symbol);
    this.hardAssert(symbol in this.boundVars, symbol + ' is not pinned');

    this.boundVars[symbol].value = value;
  }

  clone() {
    var clone = new Functor(this.compiled, this.symbols);
    for (let key in this.boundVars) {
      clone.boundVars[key] = Object.assign({}, this.boundVars[key]);
    }
    return clone;
  }

  getMinMax(unboundRanges, numSamples=200) {
    let f = this.clone();

    let unboundVars = f.unboundVars;
    if (unboundVars == 0) {
      return [f.eval(), f.eval()];
    }
    for (var i = 0; i < unboundRanges.length; i++) {
      let range = unboundRanges[i];
      let unboundVar = unboundVars[i];
      f.pinVar(unboundVar, 0, range);
    }

    let iterateSteps = {};
    let numSamplePoints = Math.round(Math.pow(numSamples, 1/f.symbols.length));
    for (let key in f.boundVars) {
      let currRange = f.boundVars[key].range;
      let rangeWidth = currRange[1]-currRange[0];
      iterateSteps[key] = rangeWidth/numSamplePoints;
    }

    var minY = Number.MAX_VALUE, maxY = -minY;
    var checkValue = function (y) {
      if (!isNaN(y)) {
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    };

    let iterate = (dimension) => {
      let currVar = f.symbols[dimension];
      let currRange = f.boundVars[currVar].range;
      let currStep = iterateSteps[currVar];
      for (let i = currRange[0]; i < currRange[1]; i+=currStep) {
        f.bindVar(currVar, i);
        if (dimension == f.symbols.length-1) {
          checkValue(f.eval());
        } else {
          iterate(dimension+1);
        }
      }
    };
    iterate(0);
    return [minY, maxY];
  }
}
</script>
