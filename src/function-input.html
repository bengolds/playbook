<link rel="import" href="mathquill/mathquill-import.html">
<link rel="import" href="hover-plot.html">
<link rel="import" href="function-parser.html">
<dom-module id="function-input">
	<link rel="import" type="css" href="mathquill/mathquill.css"/>
	<template>
		<style>
			:host {
				flex-grow: 1;
			}
			#quill {
				font-size:200%;
			}
      #errorMessage {
        color: #d40000;
        font-size: 80%;
        position: absolute;
        margin-top: 8px;
      }
      #outline {
        border-radius: 8px;
        box-shadow: 0 0 5px 5px rgba(0,0,255,0.5);
        position: absolute;
        pointer-events: none;
      }
      #hoverplot {
      	position:absolute;
      }
      .hidden {
        display:none;
      }
		</style>
	<mathquill-element id="quill" editable="true" 
   on-edit = 'onEdit'
   on-element-mouseover='onElementMouseOver'>
  </mathquill-element>
  <p id='errorMessage'></p>
  <function-parser id='parser'></function-parser>
  <div id='mouseOutOverlay'>
    <hover-plot class='hidden' id='hoverplot' x-range ='{{xRange}}'></hover-plot>
    <div id='outline' class='hidden'></div>
  </div>

</template>
<script>
  Polymer({
    is: 'function-input',

    properties: {
      functor: {
        type: Object,
        notify: true
      },
      xRange: {
        type: Array,
        notify:true
      }
    },

    ready: function() {
      this.scopeSubtree(this.$.quill, true);
      this.functor = this.$.parser.getFunctor('0');
    },

    onEdit: function() {
      var parser = this.$.parser;
      this.hideHoverItems();
      try {
        var functionString = this.$.quill.semanticText();
        if (functionString == '') {
          return;
        }
        let newFunctor = parser.getFunctor(functionString);
        this._matchPinnedVariables(this.functor, newFunctor);
        this.functor = newFunctor;
        this.$.errorMessage.textContent = '';
        this.cancelDebouncer('input-error');
        this.fire('input-ok');
      }
      catch (e) {
        this.debounce('input-error', (x)=>{
          this.$.errorMessage.textContent = e.message;
          console.log(e.stack);
          this.fire('input-error');
        }, 500);
      }
    },

    _matchPinnedVariables(oldFunctor, newFunctor) {
      if (!oldFunctor) {
        return;
      }
      for (let pinnedVar in oldFunctor.boundVars) {
        if (newFunctor.symbols.includes(pinnedVar)) {
          newFunctor.pinVar(pinnedVar, 
            oldFunctor.boundVars[pinnedVar].value, 
            oldFunctor.boundVars[pinnedVar].range);
        }
      }
    },

    onElementMouseOver: function(e, details) {
      let mqCmdId = 'mathquill-command-id';
      let mqBlockId = 'mathquill-block-id';
      let getClosestApplicationNode = (semanticNode) => {
        if (semanticNode instanceof ApplicationNode) {
          return semanticNode;
        } else if (semanticNode == null) {
          return null;
        }
        return getClosestApplicationNode(semanticNode.parent);
      };

      //Filter to make sure we're on a usable mathquill node
      let jqTarget = $(details.target);
      let id = -1;
      if (jqTarget.attr(mqBlockId)) {
        id = jqTarget.attr(mqBlockId);
      } else if (jqTarget.attr(mqCmdId)) {
        id = jqTarget.attr(mqCmdId);
      } else {
        return;
      }

      //Get the nearest Application node to the hovered object
      let semanticTree = details.mathField.semanticTree();
      let semanticNode = semanticTree.findDisplayNode(id);
      let applicationNode = getClosestApplicationNode(semanticNode);
      if (!applicationNode.parent) {
        return;
      }
      let hoveredDisplayNodes = applicationNode.getDisplayNodes();

      let outlineRect = this.getBoundingBox(hoveredDisplayNodes);
      this.drawOutline(outlineRect);
      let xCenter = outlineRect.left + (outlineRect.right-outlineRect.left)/2;
      this.createHoverPlot(xCenter, outlineRect.bottom, applicationNode.toString());
      this.listen(this.$$('#mouseOutOverlay'), 'mouseleave', 'hideHoverItems');
    },

    createHoverPlot: function(x, y, funcString) {
      this.$.hoverplot.functor = this.$.parser.getFunctor(funcString);
      this.$.hoverplot.classList.remove('hidden');
      this.$.hoverplot.style.top = y+'px';
      this.$.hoverplot.style.left = x-this.$.hoverplot.offsetWidth/2+'px';
    },

    getBoundingBox: function (nodes) {
      let merge = (r1, r2) => {
        return {
          left: Math.min(r1.left, r2.left),
          right: Math.max(r1.right, r2.right),
          top: Math.min(r1.top, r2.top),
          bottom: Math.max(r1.bottom, r2.bottom),
        };
      };

      let finalRect = {
        left: Number.MAX_VALUE,
        right: -Number.MAX_VALUE,
        top: Number.MAX_VALUE,
        bottom: -Number.MAX_VALUE,
      };
      for (var i = 0; i < nodes.length; i++) {
        let node = nodes[i].jQ[0];
        let rect = this.makeRect(node);
        finalRect = merge(finalRect, rect);
      }
      return finalRect;
    },

    makeRect: function (node) {
      return {
        left: node.offsetLeft,
        right: node.offsetLeft + node.offsetWidth,
        top: node.offsetTop,
        bottom: node.offsetTop+node.offsetHeight,
      };
    },

    drawOutline: function(rect) {
      let outline = this.$.outline;
      outline.style.top = rect.top + 'px';
      outline.style.left = rect.left + 'px';
      outline.style.width = rect.right-rect.left + 'px';
      outline.style.height = rect.bottom-rect.top + 'px';

      outline.classList.remove('hidden');
    },

    removeOutline: function () {
      this.$.outline.classList.add('hidden');
    },

    hideHoverItems: function () {
      this.unlisten(this.$$('#mouseOutOverlay'), 'mouseleave', 'hideHoverItems');
      this.$.hoverplot.classList.add('hidden'); 
      this.removeOutline();
    }

  });
</script>
</dom-module>