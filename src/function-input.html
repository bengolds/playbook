<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="hover-plot.html">
<link rel="import" href="mathquill-element.html">
<dom-module id="function-input">
	<template>
		<style>
			:host {
				flex-grow: 1;
			}
			#quill {
        --mathquill-font-size: 200%;
			}
      #errorMessage {
        color: #d40000;
        font-size: 80%;
        position: absolute;
        margin-top: 8px;
      }
      #outline {
        border-radius: 8px;
        box-shadow: 0 0 5px 5px rgba(0,0,255,0.5);
        position: absolute;
        pointer-events: none;
      }
      #hoverplot {
      	position:absolute;
      }
      .hidden {
        display:none;
      }
		</style>
	<mathquill-element id="quill" editable
    latex='{{latex}}'
    on-element-mouseover='onElementMouseOver'>
  </mathquill-element>
  <hover-plot class='hidden' id='hoverplot' 
    synced-parameters='{{syncedParameters}}'></hover-plot>
  <div id='outline' class='hidden'></div>

</template>
<script>
  Polymer({
    is: 'function-input',

    properties: {
      latex: {
        type: String,
        notify: true,
        value: '',
        observer: 'latexChanged'
      },
      definition: {
        type: String,
        notify: true,
        readOnly: true,
        value: ''
      }
    },

    attached: function() {
    },

    latexChanged: function() {
      this.tryParseLatex();
    },

    tryParseLatex: function() {
      try {
        let functionString = this.$.quill.semanticText();
        if (functionString == '') {
          return;
        }
        this._setDefinition(functionString);
        this.fire('input-ok');
        // let newFunctor = parser.getFunctor(functionString);
        // this._matchPinnedVariables(this.functor, newFunctor);
        // this.functor = newFunctor;
        // this.$.errorMessage.textContent = '';
      }
      catch (e) {
          // TODO: Move this to function row
          // this.$.errorMessage.textContent = e.message;
          // console.log(e.stack);
        this.fire('input-error', e);
      }
    },

    // _matchPinnedVariables(oldFunctor, newFunctor) {
    //   if (!oldFunctor) {
    //     return;
    //   }
    //   for (let pinnedVar in oldFunctor.boundVars) {
    //     if (newFunctor.symbols.includes(pinnedVar)) {
    //       newFunctor.pinVar(pinnedVar, 
    //         oldFunctor.boundVars[pinnedVar].value, 
    //         oldFunctor.boundVars[pinnedVar].range);
    //     }
    //   }
    // },

    onElementMouseOver: function(e, details) {
      //TODO: REMOVE THIS
      return;
      let semanticNode = mqUtil.semanticNodeFromHTML(details.target, details.mathField);
      if (!semanticNode) {
        return;
      }

      let applicationNode = mqUtil.getClosestApplicationNode(semanticNode);
      if (!applicationNode || !applicationNode.parent) {
        return;
      }

      let hoveredDisplayNodes = applicationNode.getDisplayNodes();
      let outlineRect = this.getBoundingBox(hoveredDisplayNodes);
      this.drawOutline(outlineRect);

      let xCenter = outlineRect.left + (outlineRect.right-outlineRect.left)/2;
      this.createHoverPlot(xCenter, outlineRect.bottom, applicationNode.toString());
      
      this.listen(this.$.hoverplot, 'mouseleave', 'hideHoverItems');
      this.listen(this, 'mouseleave', 'hideHoverItems');
      this.listen(this, 'mousemove', 'checkForLeaveOutline');
    },

    createHoverPlot: function(x, y, funcString) {
      //TODO: Make sure this gets the global scope
      //Move this to the main-app/global scope, and send up an event
      this.$.hoverplot.functor = this.$.parser.getFunctor(funcString);
      this.$.hoverplot.classList.remove('hidden');
      this.$.hoverplot.style.top = y+'px';
      this.$.hoverplot.style.left = x-this.$.hoverplot.offsetWidth/2+'px';
    },

    checkForLeaveOutline: function (e) {
      let rect = this.$.outline.getBoundingClientRect();
      let x = e.clientX, y = e.clientY;
      // If we're down in the hover plot, don't bother
      if (y > rect.bottom) {
        return;
      }
      else if (x < rect.left || x > rect.right || y < rect.top) {
        this.hideHoverItems();
      }
    }, 

    getBoundingBox: function (nodes) {
      let merge = (r1, r2) => {
        return {
          left: Math.min(r1.left, r2.left),
          right: Math.max(r1.right, r2.right),
          top: Math.min(r1.top, r2.top),
          bottom: Math.max(r1.bottom, r2.bottom),
        };
      };

      let finalRect = {
        left: Number.MAX_VALUE,
        right: -Number.MAX_VALUE,
        top: Number.MAX_VALUE,
        bottom: -Number.MAX_VALUE,
      };
      for (var i = 0; i < nodes.length; i++) {
        let node = nodes[i].jQ[0];
        let rect = this.makeOffsetRect(node);
        finalRect = merge(finalRect, rect);
      }
      return finalRect;
    },

    makeOffsetRect: function (node) {
      return {
        left: node.offsetLeft,
        right: node.offsetLeft + node.offsetWidth,
        top: node.offsetTop,
        bottom: node.offsetTop+node.offsetHeight,
      };
    },

    drawOutline: function(rect) {
      let outline = this.$.outline;
      outline.style.top = rect.top + 'px';
      outline.style.left = rect.left + 'px';
      outline.style.width = rect.right-rect.left + 'px';
      outline.style.height = rect.bottom-rect.top + 'px';

      outline.classList.remove('hidden');
    },

    removeOutline: function () {
      this.$.outline.classList.add('hidden');
    },

    hideHoverItems: function () {
      this.unlisten(this.$.hoverplot, 'mouseleave', 'hideHoverItems');
      this.unlisten(this, 'mouseleave', 'hideHoverItems');
      this.unlisten(this, 'mousemove', 'checkForLeaveOutline');
      this.$.hoverplot.classList.add('hidden'); 
      this.removeOutline();
    }

  });
</script>
</dom-module>