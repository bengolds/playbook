<link rel="import" href="mathquill/mathquill-import.html">
<link rel="import" href="hover-plot.html">
<link rel="import" href="function-parser.html">
<dom-module id="function-input">
	<link rel="import" type="css" href="mathquill/mathquill.css"/>
	<template>
		<style>
			:host {
				flex-grow: 1;
			}
			#quill {
				font-size:200%;
			}
      #errorMessage {
        color: #d40000;
        font-size: 80%;
        position: absolute;
        margin-top: 8px;
      }
      #outline {
        border-radius: 8px;
        box-shadow: 0 0 5px 5px rgba(0,0,255,0.5);
        position: absolute;
        pointer-events: none;
      }
      .hidden {
        display:none;
      }
		</style>
	<mathquill-element id="quill" editable="true" 
   on-edit = 'onEdit'
   on-element-mouseover='onElementMouseOver'
   on-element-mouseout= 'onElementMouseOut'>
  </mathquill-element>
  <p id='errorMessage'></p>
  <function-parser id='parser'></function-parser>
  <hover-plot class='hidden' id='hoverplot'></hover-plot>
  <div id='outline' class='hidden'></div>

</template>
<script>
  Polymer({
    is: 'function-input',

    properties: {
      functor: {
        type: Object,
        notify: true
      }
    },

    ready: function() {
      this.scopeSubtree(this.$.quill, true);
      this.functor = this.$.parser.getFunctor('0');
    },

    onEdit: function() {
      var parser = this.$.parser;
      //TODO: put in try/catch block
      try {
        var functionString = this.$.quill.semanticText();
        if (functionString == '') {
          return;
        }
        let newFunctor = parser.getFunctor(functionString);
        this._matchPinnedVariables(this.functor, newFunctor);
        this.functor = newFunctor;
        this.$.errorMessage.textContent = '';
        this.cancelDebouncer('input-error');
        this.fire('input-ok');
      }
      catch (e) {
        this.debounce('input-error', (x)=>{
          this.$.errorMessage.textContent = e.message;
          console.log(e.stack);
          this.fire('input-error');
        }, 500);
      }
    },

    _matchPinnedVariables(oldFunctor, newFunctor) {
      if (!oldFunctor) {
        return;
      }
      for (let pinnedVar in oldFunctor.boundVars) {
        if (newFunctor.symbols.includes(pinnedVar)) {
          newFunctor.pinVar(pinnedVar, 
            oldFunctor.boundVars[pinnedVar].value, 
            oldFunctor.boundVars[pinnedVar].range);
        }
      }
    },

    onElementMouseOver: function(e, details) {
      let mqCmdId = 'mathquill-command-id';
      let mqBlockId = 'mathquill-block-id';
      let getClosestApplicationNode = (semanticNode) => {
        if (semanticNode instanceof ApplicationNode) {
          return semanticNode;
        } else if (semanticNode == null) {
          return null;
        }
        return getClosestApplicationNode(semanticNode.parent);
      };

      //Filter to make sure we're on a usable mathquill node
      let jqTarget = $(details.target);
      let id = -1;
      if (jqTarget.attr(mqBlockId)) {
        id = jqTarget.attr(mqBlockId);
      } else if (jqTarget.attr(mqCmdId)) {
        id = jqTarget.attr(mqCmdId);
      } else {
        return;
      }

      //Get the nearest Application node to the hovered object
      let semanticTree = details.mathField.semanticTree();
      let semanticNode = semanticTree.findDisplayNode(id);
      let applicationNode = getClosestApplicationNode(semanticNode);
      if (!applicationNode.parent) {
        return;
      }
      let hoveredDisplayNodes = applicationNode.getDisplayNodes();

      this.drawOutline(hoveredDisplayNodes);
      this.createHoverPlot(0, 0, applicationNode.toString());
    },

    onElementMouseOut: function(e, details) {
      this.removeOutline();
      this.$.hoverplot.classList.add('hidden');
    },

    createHoverPlot: function(x, y, funcString) {
      console.log(funcString);
      this.$.hoverplot.functor = this.$.parser.getFunctor(funcString);
      this.$.hoverplot.classList.remove('hidden');
    },

    drawOutline: function(nodes) {
      let merge = (r1, r2) => {
        return {
          left: Math.min(r1.left, r2.left),
          right: Math.max(r1.right, r2.right),
          top: Math.min(r1.top, r2.top),
          bottom: Math.max(r1.bottom, r2.bottom),
        };
      };

      let finalRect = {
        left: Number.MAX_VALUE,
        right: -Number.MAX_VALUE,
        top: Number.MAX_VALUE,
        bottom: -Number.MAX_VALUE,
      };
      for (var i = 0; i < nodes.length; i++) {
        let node = nodes[i].jQ[0];
        let rect = {
          left: node.offsetLeft,
          right: node.offsetLeft+node.offsetWidth,
          top: node.offsetTop,
          bottom: node.offsetTop+node.offsetHeight
        };
        finalRect = merge(finalRect, rect);
      }

      let outline = this.$.outline;
      outline.style.top = finalRect.top + 'px';
      outline.style.left = finalRect.left + 'px';
      outline.style.width = finalRect.right-finalRect.left + 'px';
      outline.style.height = finalRect.bottom-finalRect.top + 'px';

      outline.classList.remove('hidden');
    },

    removeOutline: function () {
      this.$.outline.classList.add('hidden');
    }


  });
</script>
</dom-module>